package jschema_test

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"github.com/hlindberg/testutils"
	"github.com/wyrth-io/whit/internal/for/jschema"
	"github.com/wyrth-io/whit/internal/pio"
	"github.com/wyrth-io/whit/internal/validation"
	"github.com/wyrth-io/whit/internal/yammm"
)

func Test_Context_MarshalJSchema_sample(t *testing.T) {
	tt := testutils.NewTester(t)
	ctx := yammm.NewContext()
	reader := strings.NewReader(modelJSONBlob)
	err := ctx.SetModelFromJSON(reader)
	tt.CheckNotError(err)
	ic := validation.NewIssueCollector()
	ok := ctx.Complete(ic)
	tt.CheckTrue(ok)
	tt.CheckEqual(0, ic.Count())

	actual := new(bytes.Buffer)
	out := pio.WriterOn(actual)
	jschema.Marshal(ctx, out)

	actualSlices := strings.Split(actual.String(), "\n")
	// TODO: Construct the expected slices
	// expectedSlices := goModelBlob
	// splitSchema := strings.Split(modelJSONBlob, "\n")
	// expectedSlices = append(expectedSlices, splitSchema...)
	// expectedSlices = append(expectedSlices, "`")
	fmt.Println(actual.String())
	// TODO: Should check output against expected
	// tt.CheckStringSlicesEqual(expectedSlices, actualSlices)
	// TODO: This is a very simplistic substitute for a real test.
	tt.CheckEqual(103, len(actualSlices))
}

// TODO:
// Add Abstract, Part
// Add relationships (Composition, Association)
// Add data type
// Marshal including a data type
// Change modelJSONBlob to Yammm DSL and test various constructions separately.
// Here lint - have a cookie: .

var modelJSONBlob = //
`{
	"name": "example",
	"types": [
		{
			"name": "Student",
			"plural_name": "Students",
			"inherits": [
				"Person"
			]
		},
		{
			"name": "Person",
			"plural_name": "People",
			"properties": [
				{
					"name": "name",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"inherits": [
				"Location"
			],
			"compositions": [
				{
					"name": "HAS",
					"to": "Head",
					"optional": true,
					"many": false
				},
				{
					"name": "HAS",
					"to": "Limb",
					"optional": true,
					"many": true
				}
			],
			"associations": [
				{
					"name": "MOTHER",
					"to": "Person",
					"optional": true,
					"many": false
				},
				{
					"name": "SIBLINGS",
					"to": "Person",
					"optional": true,
					"many": true,
					"properties": [
						{
							"name": "since",
							"datatype": [
								"String"
							]
						}
					]
				}
			]
		},
		{
			"name": "Head",
			"plural_name": "Heads",
			"properties": [
				{
					"name": "hasHair",
					"datatype": [
						"Boolean"
					]
				},
				{
					"name": "id",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"is_part": true
		},
		{
			"name": "Limb",
			"plural_name": "Limbs",
			"properties": [
				{
					"name": "type",
					"datatype": [
						"String"
					]
				},
				{
					"name": "id",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"is_part": true
		},
		{
			"name": "Location",
			"plural_name": "Locations",
			"properties": [
				{
					"name": "long",
					"datatype": [
						"String"
					]
				},
				{
					"name": "lat",
					"datatype": [
						"String"
					]
				}
			],
			"is_abstract": true
		}
	],
	"data_types": [
		{
			"name": "xdate",
			"constraint": [
				"Date"
			]
		}
	]
}`

func TestJSchemaSpacevector(t *testing.T) {
	tt := testutils.NewTester(t)
	model := `schema "test"
	type Person {
		embedding Spacevector[3]
	}`
	ctx, ic := makeContext(t.Name(), model, true)
	tt.CheckEqual(0, ic.Count())
	actual := new(bytes.Buffer)
	out := pio.WriterOn(actual)
	jschema.Marshal(ctx, out)
	actualSlices := strings.Split(actual.String(), "\n")
	expected := `{
"$id": "https://wyrth-io.com/test.json",
"title": "test",
"description": "Generated by Yammm for package test",
"type": "object",
"properties": {
    "People": {
        "type": "array",
        "items": { "$ref": "#/$defs/types/Person" }
    }
},
"additionalProperties": false,
"$defs": {
"types": {
    "Person": {
        "type": "object",
        "properties": {
            "id": { "type": "string"},
            "embedding": { "type": "array", "items": {"type": "number"}, "minItems": 3, "maxItems": 3}
        },
        "required": [ "id" ],
        "additionalProperties": false
    }
}}
}
`
	expectedSlices := strings.Split(expected, "\n")
	tt.CheckStringSlicesEqual(expectedSlices, actualSlices)
}
