package jschema

import (
	"fmt"
	"strings"

	"github.com/wyrth-io/whit/internal/pio"
	"github.com/wyrth-io/whit/internal/tc"
	"github.com/wyrth-io/whit/internal/utils"
	"github.com/wyrth-io/whit/internal/yammm"
)

// Marshal produces a JSON schema representation of the context model written to the given out writer.
func Marshal(ctx yammm.Context, out *pio.Writer) {
	if !ctx.IsCompleted() {
		return
	}
	packageName := ctx.Model().Name // TODO: this is too simplistic, may want different versions etc.
	out.FormatLn("{").
		FormatLn(`"$id": "https://wyrth-io.com/%s.json",`, packageName).
		FormatLn(`"title": "%s",`, packageName).
		FormatLn(`"description": "Generated by Yammm for package %s",`, packageName)

	marshalModel(ctx, out)
	out.Println("}")
}

func marshalType(ctx yammm.Context, t *yammm.Type, out *pio.Writer) {
	indented := out.FormatLn(`"%s": {`, t.Name).Indented().
		FormatLn(`"type": "object",`).
		FormatLn(`"properties": {`)
	var required []string
	props := make([]string, 0, 10)
	for _, p := range t.AllProperties() {
		props = append(props, marshalProperty(p))
		if !p.Optional {
			required = append(required, fmt.Sprintf(`"%s"`, p.Name))
		}
	}
	for _, c := range t.AllCompositions() {
		prop, reqPropName := marshalComposition(ctx, c) // .produceJSchema(ctx)
		props = append(props, prop)
		if reqPropName != "" {
			required = append(required, fmt.Sprintf(`"%s"`, reqPropName))
		}
	}
	for _, a := range t.AllAssociations() {
		prop, reqPropName := marshalAssociation(ctx, a) // .produceJSchema(ctx)
		props = append(props, prop)
		if reqPropName != "" {
			required = append(required, fmt.Sprintf(`"%s"`, reqPropName))
		}
	}
	indented2 := indented.Indented()
	indented2.FormatJoinLn(props, ",")
	indented.FormatLn("},").
		FormatLn(`"required": [ %s ],`, strings.Join(required, ", ")).
		FormatLn(`"additionalProperties": false`).
		Outdented().
		Format("}") // Note no new line because a comma may be needed (Hate JSON no trailing comma).
}

func marshalAssociationRefs(ctx yammm.Context, a *yammm.Association, out *pio.Writer) {
	var required []string
	indented := out.
		FormatLn(`"EDGE_%s_%s": {`, a.Name, a.To).
		Indented().
		FormatLn(`"type": "object",`).
		FormatLn(`"properties": {`)
	for _, p := range a.Properties {
		indented.
			Indented().
			Format("%s,\n", marshalProperty(p))
		if !p.Optional {
			required = append(required, fmt.Sprintf(`"%s"`, p.Name))
		}
	}
	toType := ctx.LookupType(a.To)
	pkProps := make([]string, 0, 10)
	pkRequired := make([]string, 0, 5)
	// TODO: Need to sort the Pks since they were collected in a set
	for _, pk := range toType.AllPrimaryKeys() {
		pkProps = append(pkProps, marshalProperty(pk))
		pkRequired = append(pkRequired, fmt.Sprintf(`"%s"`, pk.Name))
	}
	required = append(required, `"Where"`)

	indented.
		Indented().
		FormatLn(`"Where": { `).
		Indented().
		FormatLn(`"type": "object",`).
		FormatLn(`"properties": {`).
		Indented().
		FormatJoinLn(pkProps, ",").
		Outdented().
		FormatLn("},").
		FormatLn(`"required": [ %s ]`, strings.Join(pkRequired, ", ")).
		Outdented().
		FormatLn("}"). // End Where{}
		Outdented().
		FormatLn("},"). // End "properties"; {}
		FormatLn(`"required": [ %s ]`, strings.Join(required, ", ")).
		Outdented().
		Format("}") // End EDGE_t_t {}, no newline!
}
func marshalModel(ctx yammm.Context, out *pio.Writer) {
	model := ctx.Model()
	// DOCUMENT
	indented :=
		out.FormatLn(`"type": "object",`).
			FormatLn(`"properties": {`).
			Indented()
	for i, t := range utils.Filter(model.Types, func(t *yammm.Type) bool {
		return !(t.IsAbstract || t.IsPart)
	}) {
		if i > 0 {
			out.Printf(",\n")
		}
		indented.FormatLn(`"%s": {`, t.PluralName).
			Indented().
			FormatLn(`"type": "array",`).
			FormatLn(`"items": { "$ref": "#/$defs/types/%s" }`, t.Name).
			Outdented().
			Format(`}`)
	}
	out.Printf("\n")
	out.FormatLn("},").
		FormatLn(`"additionalProperties": false,`)

	// TYPES (for edges and regular types)
	out.FormatLn(`"$defs": {`).
		FormatLn(`"types": {`)

	// Do EDGE types first since if they exist there must also be types, so last edge type can end
	// with a "," (Shakes fist at jsonschema).
	// Since all traits needs to be unrolled due to lack of working inheritance mechanism in jsonschema
	// the same asociation may appear multiple times in the output if it is not limited.
	seenAssociations := utils.NewSet[string]()
	// All EDGE_ types
	for _, t := range model.Types {
		for _, a := range t.AllAssociations() {
			if seenAssociations.Add(a.Key()) {
				// ony generate if this is the first time visiting this association
				marshalAssociationRefs(ctx, a, out.Indented())
				out.Printf(",\n")
			}
		}
	}

	// All regular types
	nTypes := len(model.Types)
	for i, t := range model.Types {
		marshalType(ctx, t, out.Indented())
		// Hate Json no trailing comma crap... the type's marshalType does not include ending
		if i < nTypes-1 {
			out.Printf(",\n")
		} else {
			out.Printf("\n")
		}
	}
	out.FormatLn("}}")
}

func marshalProperty(p *yammm.Property) string {
	if p.BaseType().Kind() != tc.SpacevectorKind {
		return fmt.Sprintf(`"%s": { "type": "%s"}`, p.Name, BaseTypeName(p))
	}
	return fmt.Sprintf(
		`"%s": { "type": "array", "items": {"type": "number"}, "minItems": %d, "maxItems": %d}`,
		p.Name, p.BaseType().Dim(), p.BaseType().Dim())
}

func marshalComposition(ctx yammm.Context, c *yammm.Composition) (jschema string, required string) {
	if c.Many {
		toType := ctx.LookupType(c.To)
		to := toType.PluralName
		return fmt.Sprintf(`"%s": { "type": "array", "items": { "$ref": "#/$defs/types/%s" }}`, to, c.To), utils.IfTrue(c.Optional, "", to)
	}
	to := c.To
	return fmt.Sprintf(`"%s": { "$ref": "#/$defs/types/%s" }`, to, to), utils.IfTrue(c.Optional, "", to)
}

func marshalAssociation(ctx yammm.Context, a *yammm.Association) (jschema string, required string) {
	if a.Many {
		key := a.Key()
		toType := ctx.LookupType(a.To)
		plural := fmt.Sprintf("%s_%s", a.Name, toType.PluralName)
		minItems := utils.IfTrue(a.Optional, 0, 1)
		return fmt.Sprintf(
				`"%s": { "type": "array", "items": { "$ref": "#/$defs/types/EDGE_%s" }, "minItems": %d }`,
				plural,
				key,
				minItems,
			),
			utils.IfTrue(a.Optional, "", plural)
	}
	key := a.Key()
	return fmt.Sprintf(
			`"%s": { "$ref": "#/$defs/types/EDGE_%s" }`,
			key,
			key,
		),
		utils.IfTrue(a.Optional, "", key)
}
