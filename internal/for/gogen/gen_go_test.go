package gogen_test

import (
	"bytes"
	"strings"
	"testing"

	"github.com/hlindberg/testutils"
	"github.com/wyrth-io/whit/internal/for/gogen"
	"github.com/wyrth-io/whit/internal/pio"
	"github.com/wyrth-io/whit/internal/validation"
	"github.com/wyrth-io/whit/internal/yammm"
)

func Test_Context_MarshalGo_sample(t *testing.T) {
	tt := testutils.NewTester(t)
	ctx := yammm.NewContext()
	reader := strings.NewReader(modelJSONBlob)
	err := ctx.SetModelFromJSON(reader)
	tt.CheckNotError(err)
	ic := validation.NewIssueCollector()
	ok := ctx.Complete(ic)
	tt.CheckTrue(ok)
	tt.CheckEqual(0, ic.Count())

	actual := new(bytes.Buffer)
	out := pio.WriterOn(actual)
	gogen.Marshal(ctx, out)

	actualSlices := strings.Split(actual.String(), "\n")
	expectedSlices := goModelBlob
	splitSchema := strings.Split(modelJSONBlob, "\n")
	expectedSlices = append(expectedSlices, splitSchema...)
	expectedSlices = append(expectedSlices, "`")
	tt.CheckStringSlicesEqual(expectedSlices, actualSlices)
}

var goModelBlob = []string{
	`// Package example is generated by whit yammm go generator. DO NOT EDIT.`,
	`package example`,
	`//nolint`,
	`type Student struct {`,
	`    Person`,
	`}`,
	`type Person struct {`,
	`    Location`,
	`    Name string ` + gogen.TagJY("name"),
	`    Head *Head ` + gogen.TagJY("Head", true),
	`    Limbs []*Limb ` + gogen.TagJY("Limbs", true),
	`    MOTHER_Person *EDGE_MOTHER_Person ` + gogen.TagJY("MOTHER_Person", true),
	`    SIBLINGS_People []*EDGE_SIBLINGS_Person ` + gogen.TagJY("SIBLINGS_People", true),
	`}`,
	`type Head struct {`,
	`    HasHair bool ` + gogen.TagJY("hasHair"), // generate lc_snake_case ?
	`    Id string ` + gogen.TagJY("id"),
	`}`,
	`type Limb struct {`,
	`    Type string ` + gogen.TagJY(("type")),
	`    Id string ` + gogen.TagJY("id"),
	`}`,
	`type Location struct {`,
	`    Long string ` + gogen.TagJY(("long")),
	`    Lat string ` + gogen.TagJY(("lat")),
	`}`,
	`type Graph struct {`,
	`    Students []*Student ` + gogen.TagJY("Students", true),
	`    People []*Person ` + gogen.TagJY("People", true),
	`}`,
	`// data type: xdate Date`,
	`type EDGE_MOTHER_Person struct {`,
	`    Where struct {`,
	`        Name string ` + gogen.TagJY("name"),
	`    } ` + gogen.TagJY("Where"),
	`}`,
	`type EDGE_SIBLINGS_Person struct {`,
	`    Since string ` + gogen.TagJY("since"),
	`    Where struct {`,
	`        Name string ` + gogen.TagJY("name"),
	`    } ` + gogen.TagJY("Where"),
	`}`,
	`const SerializedModel =` + "`", // schemaBlob needs to be added to generate the actual expected
}

var modelJSONBlob = //
`{
	"name": "example",
	"types": [
		{
			"name": "Student",
			"plural_name": "Students",
			"inherits": [
				"Person"
			]
		},
		{
			"name": "Person",
			"plural_name": "People",
			"properties": [
				{
					"name": "name",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"inherits": [
				"Location"
			],
			"compositions": [
				{
					"name": "HAS",
					"to": "Head",
					"optional": true,
					"many": false
				},
				{
					"name": "HAS",
					"to": "Limb",
					"optional": true,
					"many": true
				}
			],
			"associations": [
				{
					"name": "MOTHER",
					"to": "Person",
					"optional": true,
					"many": false
				},
				{
					"name": "SIBLINGS",
					"to": "Person",
					"optional": true,
					"many": true,
					"properties": [
						{
							"name": "since",
							"datatype": [
								"String"
							]
						}
					]
				}
			]
		},
		{
			"name": "Head",
			"plural_name": "Heads",
			"properties": [
				{
					"name": "hasHair",
					"datatype": [
						"Boolean"
					]
				},
				{
					"name": "id",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"is_part": true
		},
		{
			"name": "Limb",
			"plural_name": "Limbs",
			"properties": [
				{
					"name": "type",
					"datatype": [
						"String"
					]
				},
				{
					"name": "id",
					"datatype": [
						"String"
					],
					"primary": true
				}
			],
			"is_part": true
		},
		{
			"name": "Location",
			"plural_name": "Locations",
			"properties": [
				{
					"name": "long",
					"datatype": [
						"String"
					]
				},
				{
					"name": "lat",
					"datatype": [
						"String"
					]
				}
			],
			"is_abstract": true
		}
	],
	"data_types": [
		{
			"name": "xdate",
			"constraint": [
				"Date"
			]
		}
	]
}`

func Test_GenerateGoWithSpacevector(t *testing.T) {
	model := `schema "test"
	type Person {
		embedding Spacevector[3]
	}`
	ctx, _ := makeContext(t.Name(), model, true)
	tt := testutils.NewTester(t)

	actual := new(bytes.Buffer)
	out := pio.WriterOn(actual)
	gogen.Marshal(ctx, out)
	actualSlices := strings.Split(actual.String(), "\n")
	expected := []string{
		`type Person struct {`,
		`    Id string ` + gogen.TagJY("id"),
		`    Embedding []float32 ` + gogen.TagJY("embedding", true),
		`}`,
	}
	// Check the Person struct part (skip 3 first lines and top level output at the end
	tt.CheckStringSlicesEqual(expected, actualSlices[3:7])
}

func Test_GenerateGoDefinedDatatype(t *testing.T) {
	model := `schema "test"
	type Person {
		a Special
	}
	type Special = Integer[1,10]
	`
	ctx, _ := makeContext(t.Name(), model, true)
	tt := testutils.NewTester(t)

	actual := new(bytes.Buffer)
	out := pio.WriterOn(actual)
	gogen.Marshal(ctx, out)
	actualSlices := strings.Split(actual.String(), "\n")
	expected := []string{
		`type Person struct {`,
		`    Id string ` + gogen.TagJY("id"),
		`    A *int ` + gogen.TagJY("a", true),
		`}`,
	}
	// Check the Person struct part (skip 3 first lines and top level output at the end
	tt.CheckStringSlicesEqual(expected, actualSlices[3:7])
}
