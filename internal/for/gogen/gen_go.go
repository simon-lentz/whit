package gogen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	"github.com/pkg/errors"
	"github.com/wyrth-io/whit/internal/pio"
	"github.com/wyrth-io/whit/internal/tc"
	"github.com/wyrth-io/whit/internal/utils"
	"github.com/wyrth-io/whit/internal/yammm"
)

// Marshal outputs the given context model in golang form written to the given writer.
func Marshal(ctx yammm.Context, out *pio.Writer) {
	if !ctx.IsCompleted() {
		return
	}
	model := ctx.Model()
	packageName := model.Name // TODO: this is too simplistic, may want different versions etc.
	out.Indentedf("// Package %s is generated by whit yammm go generator. DO NOT EDIT.\n", packageName)
	out.Indentedf("package %s\n", packageName)
	out.Indentedf("//nolint\n")

	marshalModel(ctx, out)

	// All REF_TO_ and EDGE_  TODO: Are REF_TO really needed?
	typesRequiringRef := utils.NewSet[string]()
	for _, t := range model.Types {
		for _, a := range t.Associations {
			marshalAssociationRefs(ctx, a, out)
			typesRequiringRef.Add(a.To) // TODO: May not be needed
		}
	}
	// TODO: And if not needed - then this is not needed at all
	// Sort the slices since a set is unordered and if output directly will cause diffs between generated schemas
	// when there are none.
	types := typesRequiringRef.Slices()
	sort.Slice(types, func(i, j int) bool {
		return types[i] < types[j]
	})
	for _, name := range types {
		_ = ctx.LookupType(name)
		// t.marshalGoRef(out) // TODO WtF is this???
	}

	// Output the yammm schema as Json
	data, err := json.Marshal(model)
	if err != nil {
		panic(errors.Errorf("could not generate json from Yammm - %s", err.Error()))
	}
	buf := new(bytes.Buffer)
	err = json.Indent(buf, data, "", "\t")
	if err != nil {
		panic(errors.Errorf("could not generate indented json from marshaled json - %s", err.Error()))
	}
	out.Indentedf("const SerializedModel =`\n")
	out.Printf("%s\n", buf.String())
	out.Indentedf("`\n")
}

// marshalDataType produces a Go representation of the data type in the given writer.
func marshalDataType(dt *yammm.DataType, out *pio.Writer) {
	// TODO: What to do for a data type in Go?
	// Special type wrapping the basetype? If so, what good does that do?
	out.Indentedf("// data type: %s %s\n", dt.Name, strings.Join(dt.Constraint, ", "))
}

func marshalModel(ctx yammm.Context, out *pio.Writer) {
	m := ctx.Model()
	// All types
	for _, t := range m.Types {
		marshalType(ctx, t, out)
	}
	// Document
	out.Indentedf("type Graph struct {\n")
	indented := pio.IndentedWriter(out)

	for _, t := range utils.Filter(m.Types, func(t *yammm.Type) bool {
		return !(t.IsAbstract || t.IsPart)
	}) {
		indented.Indentedf("%s []*%s %s\n", t.PluralName, t.Name, TagJY(t.PluralName, true))
	}
	out.Indentedf("}\n")

	// All data types
	for _, dt := range m.DataTypes {
		marshalDataType(dt, out)
	}
}

func marshalProperty(p *yammm.Property, out *pio.Writer) {
	star := ""
	if p.Optional && p.BaseType().Kind() != tc.SpacevectorKind {
		star = "*"
	}
	out.Indentedf("%s %s%s %s\n",
		p.GoName(),
		star,
		tc.GoName(p.BaseType()),
		TagJY(p.Name, p.Optional),
	)
}

func marshalAssociation(ctx yammm.Context, a *yammm.Association, out *pio.Writer) {
	if a.Many {
		singular := fmt.Sprintf("%s_%s", a.Name, a.To)
		toType := ctx.LookupType(a.To)
		plural := fmt.Sprintf("%s_%s", a.Name, toType.PluralName)
		out.Indentedf("%s []*EDGE_%s %s\n", plural, singular, TagJY(plural, a.Optional))
	} else {
		x := fmt.Sprintf("%s_%s", a.Name, a.To)
		out.Indentedf("%s *EDGE_%s %s\n", x, x, TagJY(x, a.Optional))
	}
}

func marshalAssociationRefs(ctx yammm.Context, a *yammm.Association, out *pio.Writer) {
	out.Indentedf("type EDGE_%s_%s struct {\n", a.Name, a.To)
	indented := out.Indented()
	for _, p := range a.Properties {
		marshalProperty(p, indented)
	}
	indented.FormatLn("Where struct {")
	toType := ctx.LookupType(a.To)
	indent2 := indented.Indented()
	// TODO: Need to sort the Pks since they were collected in a set
	for _, pk := range toType.AllPrimaryKeys() {
		indent2.FormatLn("%s %s %s", utils.Capitalize(pk.Name),
			pk.BaseType().Kind().String(), TagJY(pk.Name)) // UC Go name, LC tag
	}
	indented.FormatLn("} %s", TagJY("Where"))
	out.Printf("}\n")
}

func marshalComposition(ctx yammm.Context, c *yammm.Composition, out *pio.Writer) {
	if c.Many {
		toType := ctx.LookupType(c.To)
		to := toType.PluralName
		out.Indentedf("%s []*%s %s\n", to, c.To, TagJY(to, c.Optional))
	} else {
		to := c.To
		out.Indentedf("%s *%s %s\n", to, to, TagJY(to, c.Optional))
	}
}

func marshalType(ctx yammm.Context, t *yammm.Type, out *pio.Writer) {
	out.Indentedf("type %s struct {\n", t.Name)
	indented := pio.IndentedWriter(out)
	inherits := false
	for _, st := range t.Inherits {
		indented.Indentedf("%s\n", st)
		inherits = true
	}
	for _, p := range t.Properties {
		// skip id when it is already inherited (all have id property).
		if inherits && p.Name == "id" {
			continue
		}
		marshalProperty(p, indented)
	}
	for _, c := range t.Compositions {
		marshalComposition(ctx, c, indented)
	}
	for _, a := range t.Associations {
		marshalAssociation(ctx, a, indented)
	}

	out.Indentedf("}\n")
}
